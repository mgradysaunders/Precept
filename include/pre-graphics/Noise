/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#pragma once
#ifndef PRE_GRAPHICS_SIMPLEX_NOISE
#define PRE_GRAPHICS_SIMPLEX_NOISE

#include <pre/Array>
#include <pre/random>

namespace pre {

/// A simplex noise generator.
template <std::floating_point Float, size_t N>
struct Noise {
    static_assert(N <= 16, "Probably not robust beyond 16 dimensions!");

  public:
    constexpr Noise() noexcept = default;
    constexpr Noise(std::uint32_t seed_) noexcept : seed(seed_) {
    }

    struct Result {
        Float value = 0;            ///< Value in [-1, +1].
        Array<Float, N> deriv = {}; ///< Partial derivatives.
    };
    template <std::floating_point... Floats>
    Result operator()(Floats... t) const noexcept {
        static_assert(sizeof...(Floats) == N);
        return operator()(Array{t...});
    }

    Result operator()(Array<Float, N> t) const noexcept {
        static const Float f = (1.0 / N) * (pre::sqrt(1.0 + N) - 1.0);
        static const Float g = (1.0 / N) * (1.0 - 1.0 / pre::sqrt(1.0 + N));
        Array<Float, N> skew = t + f * t.sum();
        Array<int, N> skew0 = fast_floor(skew);
        skew -= skew0;
        int skew0_sum = skew0.sum();
        Array<int, N> skew_index = skew0;
        Array<int, N> skew_order = skew.sorted_indexes().reversed();
        Result result;
        for (int k = 0; k <= int(N); k++) {
            Array<Float, N> corner = skew_index - g * (skew0_sum + k);
            Array<Float, N> offset = t - corner;
            if (Float env = Float(0.5) - dot(offset, offset); env > 0) {
                Pcg32 rand(seed, cantor(skew_index));
                Array<Float, N> grad(rand, [](auto& rand) {
                    return (Float(2) / Float(15)) * rand(16) - Float(1);
                });
                Float proj = dot(grad, offset);
                Float env2 = env * env;
                result.value += env2 * proj;
                result.deriv += env2 * grad - 4 * env * proj * offset;
            }
            if (k < int(N))
                ++skew_index[skew_order[k]];
        }
        result.value *= 20;
        result.deriv *= 20;
        if (pre::abs(result.value) > Float(0.5)) {
            Float sat = pre::exp(1 - 2 * pre::abs(result.value));
            result.value =
                    pre::copysign(Float(1), result.value) * (1 - sat / 2);
            result.deriv *= sat;
        }
        return result;
    }

  public:
    std::uint32_t seed = 0;
};

template <std::floating_point Float = float>
using Noise1 = Noise<Float, 1>;

template <std::floating_point Float = float>
using Noise2 = Noise<Float, 2>;

template <std::floating_point Float = float>
using Noise3 = Noise<Float, 3>;

template <std::floating_point Float = float>
using Noise4 = Noise<Float, 4>;

} // namespace pre

#endif // #ifndef PRE_GRAPHICS_SIMPLEX_NOISE
