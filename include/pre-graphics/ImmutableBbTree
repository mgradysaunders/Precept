/*-*- C++ -*-*/
/* Copyright (c) 2018-21 M. Grady Saunders
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 *   1. Redistributions of source code must retain the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer.
 *
 *   2. Redistributions in binary form must reproduce the above
 *      copyright notice, this list of conditions and the following
 *      disclaimer in the documentation and/or other materials
 *      provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*-*-*-*-*-*-*/
#pragma once
#ifndef PRE_GRAPHICS_IMMUTABLE_BB_TREE
#define PRE_GRAPHICS_IMMUTABLE_BB_TREE

#include <pre/memory>
#include <pre-graphics/Bound>
#include <pre-graphics/GrowableStack>

namespace pre {

/// An immutable bounding volume hierarchy.
template <size_t Dim>
class ImmutableBbTree {
    static_assert(Dim == 2 or Dim == 3);

  public:
    using Box = Bound<float, Dim>;
    using Point = Array<float, Dim>;

    struct Node {
        /// Bound box.
        Box box;
        union {
            /// If branch, right child offset.
            std::uint32_t right;
            /// If leaf, first item.
            std::uint32_t first;
        };
        /// If leaf, item count.
        std::uint8_t count;
        /// If branch, split axis.
        std::uint8_t split_axis;

        constexpr bool is_leaf() const noexcept {
            return count != 0;
        }
        constexpr bool is_branch() const noexcept {
            return count == 0;
        }

        template <typename Range>
        constexpr auto values(const Range& range) const noexcept {
            ASSERT(count > 0);
            return IteratorRange(                    //
                    std::next(range.begin(), first), //
                    std::next(range.begin(), first + count));
        }

        void serialize(auto& serializer) {
            serializer <=> box;
            serializer <=> right;
            serializer <=> count;
            serializer <=> split_axis;
        }
    };

    struct Item {
        int index = 0;
        Box box;
        Point box_center;
    };

    using Nodes = std::vector<Node>;
    using Items = std::vector<Item>;

  public:
    void build(int leaf_limit, Items& items);

    void clear() {
        nodes.clear();
    }

    template <std::invocable<const Node*> Func>
    void ray_cast(const Ray<float, Dim>& ray, Func&& func) const {
        RayTester<Box> ray_tester(ray);
        GrowableStack<const Node*> todo;
        if (nodes.size() > 0)
            todo.push(&nodes[0]);
        while (not todo.empty()) {
            const Node* node = todo.pop();
            if (not ray_tester(node->box))
                continue; // Skip

            if (node->is_branch()) {
                todo.push(node + 1);
                todo.push(node + node->right);

                // If ray direction is positive in splitting dimension
                // of the branch, then reverse the traversal order of the
                // children, so that the left child is first.
                if (pre::signbit(ray.dir[node->split_axis]) == false)
                    std::swap(todo[-1], todo[-2]);
            }
            else {
                // Pass to leaf callback
                if (std::invoke(func, node) == false)
                    return;
            }
        }
    }

    void serialize(auto& serializer) {
        serializer <=> nodes;
    }

  public:
    Nodes nodes;
};

using ImmutableBbTree2 = ImmutableBbTree<2>;

using ImmutableBbTree3 = ImmutableBbTree<3>;

} // namespace pre

#endif // #ifndef PRE_GRAPHICS_IMMUTABLE_BB_TREE
